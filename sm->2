pragma solidity ^0.4.24;

contract sm2{
    mapping (bytes32 => uint) public cnt;
    mapping (address => bool) public volid;
    mapping (bytes32 => bool) public check;
    constructor(address[]volidators){
        for(uint i = 0; i<volidators.length;i++){
            volid[volidators[i]] = true;
        }
    }
    uint num = 1;
    uint tm;
    event MessageSucessfulPassed(address indexed addre,bytes  byt);
    event MessagePassFail(address indexed ad,bytes by);
    address a;
    function passSignatures(address _addre, bytes _data, bytes32 _trhhash,uint8[] _v,bytes32[] _r,bytes32[] _s){
        for( tm = 0;tm<num;tm++){
            a=ecrecover(keccak256(_addre,_data,_trhhash),_v[tm],_r[tm],_s[tm]);   
            require(volid[a] == true);
            bytes32 hash = keccak256(a, _addre, _data, _trhhash);
            require(check[hash] == false);
            check[hash] = true;
            hash = keccak256(_addre, _data, _trhhash);
            cnt[hash]++;
            require(cnt[hash]==num);
        }
        if(tm==num){
            PassMesage(_addre,_data);
        }
    }
    
    
    
    
    function PassMesage (address _addre, bytes _data)private{
      
        if(_addre.call(_data) == true){
            MessageSucessfulPassed(_addre,_data);
            return;
            tm=0;
        }
        else{
            MessagePassFail(_addre,_data);
            return; 
            tm=0;
        }
    }
}
