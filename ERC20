pragma solidity ^0.4.4;

contract Token {
    event Transfer(address indexed _from, address indexed _to, uint256 _value);
    event Approval(address indexed _owner, address indexed _spender, uint256 _value);
    
    mapping (address => uint256) monn;
    mapping (address => mapping (address => uint256)) allowed;
    uint256 public totalMoney;
    string public name;                  
    uint8 public decimals;               
    string public symbol;                
    string public version = 'H1.0'; 
    uint256 public unitsOneEthCanBuy;     
    uint256 public totalEthInWei;         
    address public fundsWallet;           

    function transfer(address _to, uint256 _money)returns(bool success) {
            if (monn[msg.sender]>=_money && _money > 0) {
                monn[msg.sender]-=_money;
                monn[_to]+=_money;
                Transfer(msg.sender, _to, _money);
                return true;
            }
            else { 
                return false;
            }
    }

    function transferFrom(address _from, address _to, uint256 _money)returns(bool success) {
        if (monn[_from]>=_money && allowed[_from][msg.sender] >= _money && _money > 0) {
            monn[_to]+=_money;
            monn[_from]-=_money;
            allowed[_from][msg.sender]-=_money;
            Transfer(_from,_to,_money);
            return true;
        } else { return false; }
    }

    function balanceOf(address _gin)constant returns(uint256 balance) {
        return monn[_gin];
    }

    function approve(address _from, uint256 _money)returns(bool success) {
        allowed[msg.sender][_from]=_money;
        Approval(msg.sender, _from, _money);
        return true;
    }

    function allowance(address _owner, address _spender)constant returns(uint256 remaining) {
      return allowed[_owner][_spender];
    }

    function HashnodeTestCoin() {
        monn[msg.sender] = 100000;               
        totalMoney = 1000000;                    
        name = "Dimasik";                        
        decimals = 0;                            
        symbol = "DMK";                         
        unitsOneEthCanBuy = 100;                  
        fundsWallet = msg.sender;                
    }

    function() payable{
        totalEthInWei = totalEthInWei + msg.value;
        uint256 amount = msg.value * unitsOneEthCanBuy;
        require(monn[fundsWallet] >= amount);
        monn[fundsWallet] = monn[fundsWallet] - amount;
        monn[msg.sender] = monn[msg.sender] + amount;
        Transfer(fundsWallet, msg.sender, amount); 
        fundsWallet.transfer(msg.value);                               
    }
    function approveAndCall(address _spender, uint256 _value, bytes _extraData)returns(bool success) {
        allowed[msg.sender][_spender] = _value;
       Approval(msg.sender, _spender, _value);
        if(!_spender.call(bytes4(bytes32(sha3("receiveApproval(address,uint256,address,bytes)"))), msg.sender, _value, this, _extraData)) { throw; }
        return true;
    }
}
