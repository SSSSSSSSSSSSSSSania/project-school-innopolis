pragma solidity ^0.4.11;
contract sm1{

    mapping (bytes32 => uint) public cnt;
    mapping (address => bool) public volid;
    mapping (bytes32 => bool) public check;
    uint num = 1;
    
    constructor(address[]volidators){
        for(uint i = 0; i<volidators.length;i++){
            volid[volidators[i]] = true;
        }
    }
    
    function transwerMessage(address _to, bytes _data) public{
        RequessToPasMessage(_to, _data);
    }
    
    event RequessToPasMessage(
       address _to,
       bytes _data
    );
    
    function transwerVRS(address _to, bytes _data, bytes32 _trhhash, uint8[] _V, bytes32[] _R, bytes32[] _S) public{
        RequessToPasVRS(_to, _data, _trhhash, _V, _R, _S);
    }
    
    event RequessToPasVRS(
        address _to,
        bytes _data,
        bytes32 _trhhash,
        uint8[] _V,
        bytes32[] _R,
        bytes32[] _S
    );
    
    
    uint8[]public V;
    bytes32[]public R;
    bytes32[]public S;
    
    function signMessage(address _to, bytes _data, bytes32 _trhhash, uint8 _v, bytes32 _r, bytes32 _s) {
        bytes32 Hash = keccak256(_to, _data, _trhhash);
        address addre = ecrecover(Hash, _v, _r, _s);
        require(volid[addre] == true);
        bytes32 hash = keccak256(addre, _to, _data, _trhhash);
        require(check[hash] == false);
        check[hash] = true;
        hash = keccak256(_to, _data, _trhhash);
        cnt[hash]++;
        V.push(_v);
        R.push(_r);
        S.push(_s);
        if(cnt[hash]==num){
            transwerVRS(_to, _data, _trhhash, V, R, S);
        }
    }
}
