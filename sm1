pragma solidity ^0.4.11;
contract sm1{

    mapping (bytes32 => uint) public cnt;
    mapping (address => bool) public volid;
    mapping (bytes32 => bool) public check;
    uint num = 2;
    address addrRecov;
    uint8[]public V;
    bytes32[]public R;
    bytes32[]public S;
    constructor(address[]volidators){
        for(uint i = 0; i<volidators.length;i++){
            volid[volidators[i]] = true;
        }
    }
    
    function PassMesage (address _to, bytes _data, bytes32 _trhhash){
        if(volid[msg.sender] == true){
            volid[msg.sender] = false;
            bytes32 hash = keccak256(msg.sender, _to, _data, _trhhash);
            if(check[hash] == false){
                check[hash] = true;
                hash = keccak256(_to, _data, _trhhash);
                cnt[hash]++;
                if(cnt[hash] == num){
                    if(_to.call(_data) == true){
                        MessageSucessfulPassed(_to, _data);
                    }
                    else{
                         MessagePassFail(_to, _data);
                    }
                }
            }
        }
    }
    event MessageSucessfulPassed(
        address indexed addre,
        bytes  byt
    );
    event MessagePassFail(
        address indexed ad,
        bytes by
    );
    
    
    
    
    
    
    
    
    function transwerMessage(address _to, bytes _data) public{
        RequessToPasMessage(_to, _data);
    }
    
    event RequessToPasMessage(
       address _to,
       bytes _data
    );
    
    function signMessage(address _to, bytes _data, bytes32 _trhhash, uint8 _v, bytes32 _r, bytes32 _s) {
        addrRecov = ecrecover(keccak256(_to, _data, _trhhash), _v, _r, _s);
        require(volid[addrRecov] == true);
        bytes32 hash = keccak256(addrRecov, _to, _data, _trhhash);
        require(check[hash] == false);
        check[hash] = true;
        hash = keccak256(_to, _data, _trhhash);
        cnt[hash]++;
        V.push(_v);
        R.push(_r);
        S.push(_s);
        if(cnt[hash] == num){
            transwerVRS(_to, _data, _trhhash, V, R, S);
        }
    }
    function transwerVRS(address _to, bytes _data, bytes32 _trhhash, uint8[] _V, bytes32[] _R, bytes32[] _S) public{
        RequessToPasVRS(_to, _data, _trhhash, _V, _R, _S);
    }
    event RequessToPasVRS(
        address _to,
        bytes _data,
        bytes32 _trhhash,
        uint8[] _V,
        bytes32[] _R,
        bytes32[] _S
    );
}
